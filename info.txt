pro tips =>
1.whenever talk to database you must use try and catch and async await.
2.think as database is in difft continent so u shld alw use async await.

try {
    const connectionInstance = await mongoose.connect(`${process.env.MONGODB_URL}/${DB_NAME}`);
    console.log(`\n MongoDB connected !! DB HOST: ${connectionInstance.connection.host}`);//this is tell whole url where mongodb connection happens
    //this is to check if we by mistake we connect to difft url than production and get to know on which connection we are connecting
  } catch (error) {
    console.log("MONGODB connection failed ", error);//these logs are very impotant to see where i m doing the errors
    process.exit(1);
    // process.exit(code)
    // -> Immediately stops the Node.js process
    // -> Exit code convention:
    //    0 = success (program finished correctly)
    //    1 = failure (program crashed or critical error)
    // -> Often used in scripts, CI/CD, or when app cannot recover
  }


We use mongoose-aggregate-paginate-v2 so our apps donâ€™t get overloaded when
showing lots of data. It breaks big results into small, easy-to-read pages â€”
just like flipping through a comic book instead of carrying the whole library at once.
we will use it in video.models.js



we will use cloudnary and multer for uploading file 


multer =>it will not process any form which is not multipart(therefor enctype="multipart/form-data" is needed)
for uploading file
<form action="/upload" method="post" enctype="multipart/form-data">
  <input type="file" name="myFile" />
  <button type="submit">Upload</button>
</form>


- enctype â†’ Stands for encoding type. It tells the browser how to encode the form data before sending it to the server.
- multipart/form-data â†’ Used when your form includes file uploads.
- It splits the form data into multiple parts (text fields + binary file data).
- Each part is separated by a boundary string.


// ğŸ“¦ MULTER SETUP FOR FILE UPLOADS

const express = require('express')         // Import Express framework
const multer = require('multer')           // Import Multer middleware

// ğŸ—‚ï¸ Configure Multer to store uploaded files in 'uploads/' directory

// ================= Multer Config Cheat Sheet =================
//
// 1. Using `dest`
// -------------------------------------------------------------
// const upload = multer({ dest: 'uploads/' });
// - Quick setup: tells Multer to save files in 'uploads/' folder.
// - Filenames are auto-generated (random safe IDs).
// - No control over naming or dynamic destination.
// - Good for demos, testing, or when you donâ€™t care about filenames.
//
// ğŸ§ª This setup allows you to handle file uploads like:
// app.post('/profile', upload.single('avatar'), (req, res) => {
//   console.log(req.file)   // Access uploaded file metadata
//   console.log(req.body)   // Access other form fields
//   res.send('File uploaded!')
// })

// 2. Using `storage`
// -------------------------------------------------------------
// const storage = multer.diskStorage({
//   destination: (req, file, cb) => cb(null, 'uploads/'), // custom folder
//   filename: (req, file, cb) => cb(null, Date.now() + '-' + file.originalname) // custom name
// });
// const upload = multer({ storage: storage });
// - Full control over where files go and how theyâ€™re named.
// - Can use logic (timestamps, user IDs, file types).
// - Productionâ€‘ready: predictable filenames, easy to save paths in DB.
//
 
// ğŸš€ Create Multer instance with diskStorage
const upload = multer({ storage: storage });

// ğŸ› ï¸ Route to handle file upload
app.post('/upload', upload.single('myFile'), (req, res) => {
  // ğŸ“¦ Access uploaded file metadata
  console.log(req.file);

  // ğŸ§¾ Access other form fields (if any)
  console.log(req.body);

  res.send('File uploaded successfully!');
});


//accessing file in both formate is same whether it is using storage or dest


// Single file upload
app.post('/profile', upload.single('avatar'), (req, res) => {
  console.log(req.file);   // one file
});

// Multiple files under one field
app.post('/gallery', upload.array('photos', 5), (req, res) => {
  console.log(req.files);  // array of files
});

// Multiple fields with different names
app.post('/profile', upload.fields([
  { name: 'avatar', maxCount: 1 },
  { name: 'coverImage', maxCount: 1 }
]), (req, res) => {
  console.log(req.files.avatar);     // array with avatar file
  console.log(req.files.coverImage); // array with cover image
});

// No files, only text fields
app.post('/form', upload.none(), (req, res) => {
  console.log(req.body);   // text fields only
});


http =>hyper text transfer protocol


url -uniform resource locator
uri - identifier
urn - name

// ğŸŒ HTTP HEADERS â€” CHEAT SHEET STYLE

// ğŸ“¦ What are HTTP headers?
// Headers = metadata sent as key-value pairs with every HTTP request and response
// Used for: caching, authentication, managing state, compression, etc.

// ğŸ§­ Types of Headers:

// 1ï¸âƒ£ Request Headers â†’ sent from client (e.g., browser)
//     - Examples: Authorization, User-Agent, Accept, Cookie

// 2ï¸âƒ£ Response Headers â†’ sent from server
//     - Examples: Set-Cookie, Content-Type, Cache-Control

// 3ï¸âƒ£ Representation Headers â†’ describe encoding/compression
//     - Examples: Content-Encoding, Content-Language

// 4ï¸âƒ£ Payload Headers â†’ describe actual data
//     - Examples: Content-Length, Content-Type

// âš ï¸ Legacy Note:
// "X-" prefix headers (e.g., X-Powered-By) were common pre-2012 but are now deprecated


// ğŸŒ HTTP HEADERS â€” MOST COMMON, CORS, SECURITY

// ğŸ”¸ Most Common Headers
// Accept: 'application/json'         // Client expects JSON response
// User-Agent: 'Mozilla/5.0'          // Info about konsi application se req aayi hai eg: browser,postman
// Authorization: 'Bearer <token>'    // Used for authentication
// Content-Type: 'application/json'   // Format of request body
// Cookie: 'sessionId=abc123'         // Client-side state management
// Cache-Control: 'no-cache'          // Caching behavior

these below does not do anything these are just internal policies of companies that kha kha se req aa skti hai
ye sirf header info  but isme aapko he code likhna hota hai

// ğŸ”¸ CORS Headers (Cross-Origin Resource Sharing)
// Access-Control-Allow-Origin: '*' or specific domain
// Access-Control-Allow-Credentials: true/false
// Access-Control-Allow-Methods: 'GET, POST, PUT, DELETE'

// ğŸ”¸ Security Headers
// Cross-Origin-Embedder-Policy: 'require-corp'         // Blocks untrusted embeds
// Cross-Origin-Opener-Policy: 'same-origin'            // Isolates browsing context
// Content-Security-Policy: "default-src 'self'"        // Prevents XSS, data injection
// X-XSS-Protection: '1; mode=block'                    // Legacy XSS protection (deprecated)

// ğŸŒ HTTP METHODS â€” CHEAT SHEET

// Basic set of operations used to interact with a server

// ğŸ”¹ GET
// Retrieve a resource (e.g., fetch user profile, list of posts)

// ğŸ”¹ HEAD[less use]
// Like GET but returns only headers (no body); used for metadata checks

// ğŸ”¹ OPTIONS[less use]
// Ask the server what methods are allowed on a resource (CORS preflight)

// ğŸ”¹ TRACE
// Loopback test â€” echoes the request back for debugging

// ğŸ”¹ DELETE
// Remove a resource (e.g., delete user, remove post)

// ğŸ”¹ PUT
// Replace a resource entirely (idempotent â€” same result every time)

// ğŸ”¹ POST
// Create or interact with a resource (commonly used to add new data)

// ğŸ”¹ PATCH
// Modify part of a resource (partial update â€” not full replacement)



// ğŸŒ HTTP STATUS CODES â€” CHEAT SHEET

// ğŸ”¹ 1xx â€” Informational
// 100: Continue               // Client should continue with request
// 102: Processing             // Server has accepted but not completed the request

// ğŸ”¹ 2xx â€” Success
// 200: OK                     // Standard success response
// 201: Created                // Resource successfully created
// 202: Accepted               // Request accepted but not yet processed

// ğŸ”¹ 3xx â€” Redirection
// 307: Temporary Redirect     // Resource temporarily moved
// 308: Permanent Redirect     // Resource permanently moved

// ğŸ”¹ 4xx â€” Client Error[client se info sahi se nhi aayi hai]
// 400: Bad Request            // Malformed syntax or invalid request
// 401: Unauthorized           // Authentication required[u r lofgin but u r not authorised]
// 402: Payment Required       // Reserved for future use
// 404: Not Found              // Resource doesn't exist

// ğŸ”¹ 5xx â€” Server Error
// 500: Internal Server Error  // Generic server failure
// 504: Gateway Timeout        // Server didnâ€™t get response from upstream





//Think of ApiError as a custom envelope for your backend errors â€”
//it wraps the raw error in a structured format so your API responses
//are clean, predictable, and easy to debug.

class ApiError extends Error {
  constructor(
    statusCode,
    message = "Something went wrong",
    errors = [],
    stack = ""
  ) {
    super(message);
    this.statusCode = statusCode;
    this.data = null;
    this.message = message;
    this.success = false;
    this.errors = errors;

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

export { ApiError };

// ---------------- STACK HANDLING IN ApiError ----------------

// Every Error object in JS has a "stack" property
// - It's a string showing the call path (functions + line numbers)
// - Example output:
//   ApiError: Something went wrong
//       at someFunction (file.js:10:5)
//       at anotherFunction (file.js:20:3)

// In ApiError constructor:
// if (stack) {
//   this.stack = stack;
//   // ğŸ‘‰ If a custom stack string is passed in, use it directly.
//   // Example:
//   // new ApiError(400, "Bad Request", [], "Custom stack trace here")
//   // => err.stack === "Custom stack trace here"
// } else {
//   Error.captureStackTrace(this, this.constructor);
//   // ğŸ‘‰ If no custom stack is provided:
//   // - Node.js auto-generates a stack trace
//   // - captureStackTrace attaches the breadcrumb trail of calls
//   // - Excludes the constructor itself for cleaner output
//   // - Helps developers debug by showing where the error originated
// }

if (
    [fullname, email, username, password].some((field) => field?.trim() === "")
  )
// [fullname, email, username, password]
// ğŸ‘‰ Creates an array containing the four variables

// .some(callback)
// ğŸ‘‰ Array method that checks if *at least one* element
//    satisfies the condition inside the callback
// ğŸ‘‰ Returns true if any element passes, false otherwise

// (field) => field?.trim() === ""
// ğŸ‘‰ Callback function run on each element (fullname, email, etc.)
// ğŸ‘‰ field?.trim():
//    - ?. is optional chaining â†’ avoids errors if field is null/undefined
//    - .trim() removes whitespace from start and end of the string
// ğŸ‘‰ === "" checks if the trimmed string is empty

// So overall:
// - Loop through [fullname, email, username, password]
// - For each field, trim whitespace
// - If any field is empty (""), .some() returns true
// - Otherwise, returns false



// Multer configuration: handle multiple file fields in a single form submission
upload.fields([
  {
    name: "avatar",    // field name expected in the form-data (e.g. <input type="file" name="avatar">)
    maxCount: 1        // allow only 1 file for this field; Multer will still store it in an array
  },
  {
    name: "coverImage", // another field name (e.g. <input type="file" name="coverImage">)
    maxCount: 1         // allow only 1 file for this field as well
  }
]);

// After this middleware runs, Multer will populate req.files like:
// {
//   avatar: [ { ...fileObject } ],      // array containing the uploaded avatar file
//   coverImage: [ { ...fileObject } ]   // array containing the uploaded cover image file
// }
//
// Each fileObject includes metadata such as:
// fieldname, originalname, mimetype, destination, filename, path, size
//
// Example access:
// const avatarLocalPath = req.files?.avatar?.[0]?.path;       // path of uploaded avatar
// const coverImageLocalPath = req.files?.coverImage?.[0]?.path; // path of uploaded cover image
//
// Note: [0] is required because Multer always stores files in arrays,
// even if maxCount = 1.

//=============================uploading file on cloudinary======================================

const uploadOnCloudinary = async (localFilePath) => {
  try {
    if (!localFilePath) return null;
    //upload the file on cloudinary
    const response = await cloudinary.uploader.upload(localFilePath, {
      resource_type: "auto",//it will automatically detect the type of file
    });
    console.log("file uploaded on cloudinary ", response.url); 
    return response;
  } catch (error) {
    fs.unlinkSync(localFilePath);//remove the file from local server if any error occurs
    console.log("Error in uploading file on cloudinary", error);
    return null;
  }
};

{
  asset_id: "abc123xyz",        // unique ID for the asset
  public_id: "folder/filename", // the public identifier you can use to access it
  version: 1678901234,          // version number
  width: 800,                   // width in pixels (for images)
  height: 600,                  // height in pixels
  format: "jpg",                // file format
  resource_type: "image",       // type of resource (image, video, raw, etc.)
  created_at: "2026-01-02T14:21:00Z", // upload timestamp
  bytes: 123456,                // file size in bytes
  type: "upload",               // delivery type
  url: "http://res.cloudinary.com/.../filename.jpg", // direct URL to the file
  secure_url: "https://res.cloudinary.com/.../filename.jpg" // HTTPS URL
}





// Using Mongoose .select() to control which fields are returned
// -------------------------------------------------------------
// User.findById(user._id) â†’ finds the user document by its unique _id
// .select("-password -refreshToken") â†’ exclude these fields from the result
//   - The minus sign (-) means "do not include this field"
//   - Useful for hiding sensitive data like hashed passwords or tokens
//
// Example:
// Without .select â†’ result includes all fields (name, email, password, refreshToken, etc.)
// With .select("-password -refreshToken") â†’ result excludes those fields
//
// So createdUser will contain only safe fields (like _id, name, email),
// while password and refreshToken are filtered out.
const createdUser = await User.findById(user._id).select("-password -refreshToken");




visit 30 min video 15 it tells you something important abt postman




diffce between refce token and access token =>


/*
================ Access Token vs Refresh Token =================



1ï¸âƒ£ Access Token
- Purpose: Used to access protected APIs/routes.
- Lifespan: Short-lived (e.g., 15min â€“ 1h)
- Sent with API requests in headers: Authorization: Bearer <access_token>
- Storage: Memory, localStorage, or cookie
- Security: If stolen, risk is limited due to short lifespan

2ï¸âƒ£ Refresh Token
- Purpose: Used to get a new access token without asking the user to log in again.
- Lifespan: Long-lived (e.g., 7â€“10 days)
- Storage: httpOnly cookie (recommended) or secure storage
- Security: High risk if stolen (can mint new access tokens)
- Not sent on every API request â€” only when refreshing access token

================ Key Differences =================

| Feature          | Access Token              | Refresh Token                  |
|-----------------|---------------------------|--------------------------------|
| Purpose         | Access APIs/resources    | Renew access token             |
| Lifespan        | Short (minutesâ€“hours)    | Long (daysâ€“weeks)              |
| Storage         | Memory / localStorage / cookie | HttpOnly cookie / secure storage |
| Security Risk   | Low (short-lived)        | High (can generate new access tokens) |
| Sent in requests| Yes (Authorization header) | No, only during refresh        |
| Rotation        | Not rotated              | Should rotate / can revoke     |

================ Analogy =================
- Access Token = Your room key (works only a short time)
- Refresh Token = Front desk master card (get new keys without leaving hotel)

================ Best Practices =================
- Keep access tokens short-lived
- Keep refresh tokens secure (httpOnly cookie)
- Validate refresh token carefully before issuing new access token
*/




// =======================
// FRONTEND (React / Vanilla JS)
// =======================

// -----------------------
// 1ï¸âƒ£ LOGIN FUNCTION
// -----------------------
// - User submits username + password
// - We call backend /login
// - Backend responds with { accessToken }
// - We save the token in localStorage (or cookie)
async function login(username, password) {
  try {
    const res = await axios.post("http://localhost:8000/login", {
      username,
      password
    });

    // Save token securely
    localStorage.setItem("accessToken", res.data.accessToken);

    console.log("Login successful, token stored!");
  } catch (err) {
    console.error("Login failed:", err.response?.data || err.message);
  }
}

// -----------------------
// 2ï¸âƒ£ GET TOKEN HELPER
// -----------------------
// - Retrieve token from localStorage
// - Used in API calls
function getToken() {
  return localStorage.getItem("accessToken");
}

// -----------------------
// 3ï¸âƒ£ API CALL WITH TOKEN
// -----------------------
// - Attach token to Authorization header
// - Server reads it via req.header("authorization")
async function getUserProfile() {
  const token = getToken();

  if (!token) {
    console.error("No token found, please login first!");
    return;
  }

  try {
    const res = await axios.get("http://localhost:8000/api/user", {
      headers: {
        Authorization: `Bearer ${token}` // ğŸ‘ˆ this is what Express middleware checks
      }
    });

    console.log("User profile:", res.data);
  } catch (err) {
    console.error("Error fetching profile:", err.response?.data || err.message);
  }
}

// -----------------------
// 4ï¸âƒ£ LOGOUT FUNCTION
// -----------------------
// - Remove token from storage
// - User must login again to get a new token
function logout() {
  localStorage.removeItem("accessToken");
  console.log("Logged out, token cleared!");
}

// -----------------------
// 5ï¸âƒ£ USAGE EXAMPLE
// -----------------------
// - Call login, then fetch profile
// login("girish", "1234").then(() => getUserProfile());

