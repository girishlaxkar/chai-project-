pro tips =>
1.whenever talk to database you must use try and catch and async await.
2.think as database is in difft continent so u shld alw use async await.

try {
    const connectionInstance = await mongoose.connect(`${process.env.MONGODB_URL}/${DB_NAME}`);
    console.log(`\n MongoDB connected !! DB HOST: ${connectionInstance.connection.host}`);//this is tell whole url where mongodb connection happens
    //this is to check if we by mistake we connect to difft url than production and get to know on which connection we are connecting
  } catch (error) {
    console.log("MONGODB connection failed ", error);//these logs are very impotant to see where i m doing the errors
    process.exit(1);
    // process.exit(code)
    // -> Immediately stops the Node.js process
    // -> Exit code convention:
    //    0 = success (program finished correctly)
    //    1 = failure (program crashed or critical error)
    // -> Often used in scripts, CI/CD, or when app cannot recover
  }


We use mongoose-aggregate-paginate-v2 so our apps don‚Äôt get overloaded when
showing lots of data. It breaks big results into small, easy-to-read pages ‚Äî
just like flipping through a comic book instead of carrying the whole library at once.
we will use it in video.models.js



we will use cloudnary and multer for uploading file 


multer =>it will not process any form which is not multipart(therefor enctype="multipart/form-data" is needed)
for uploading file
<form action="/upload" method="post" enctype="multipart/form-data">
  <input type="file" name="myFile" />
  <button type="submit">Upload</button>
</form>


- enctype ‚Üí Stands for encoding type. It tells the browser how to encode the form data before sending it to the server.
- multipart/form-data ‚Üí Used when your form includes file uploads.
- It splits the form data into multiple parts (text fields + binary file data).
- Each part is separated by a boundary string.


// üì¶ MULTER SETUP FOR FILE UPLOADS

const express = require('express')         // Import Express framework
const multer = require('multer')           // Import Multer middleware

// üóÇÔ∏è Configure Multer to store uploaded files in 'uploads/' directory

// ================= Multer Config Cheat Sheet =================
//
// 1. Using `dest`
// -------------------------------------------------------------
// const upload = multer({ dest: 'uploads/' });
// - Quick setup: tells Multer to save files in 'uploads/' folder.
// - Filenames are auto-generated (random safe IDs).
// - No control over naming or dynamic destination.
// - Good for demos, testing, or when you don‚Äôt care about filenames.
//
// üß™ This setup allows you to handle file uploads like:
// app.post('/profile', upload.single('avatar'), (req, res) => {
//   console.log(req.file)   // Access uploaded file metadata
//   console.log(req.body)   // Access other form fields
//   res.send('File uploaded!')
// })

// 2. Using `storage`
// -------------------------------------------------------------
// const storage = multer.diskStorage({
//   destination: (req, file, cb) => cb(null, 'uploads/'), // custom folder
//   filename: (req, file, cb) => cb(null, Date.now() + '-' + file.originalname) // custom name
// });
// const upload = multer({ storage: storage });
// - Full control over where files go and how they‚Äôre named.
// - Can use logic (timestamps, user IDs, file types).
// - Production‚Äëready: predictable filenames, easy to save paths in DB.
//
 
// üöÄ Create Multer instance with diskStorage
const upload = multer({ storage: storage });

// üõ†Ô∏è Route to handle file upload
app.post('/upload', upload.single('myFile'), (req, res) => {
  // üì¶ Access uploaded file metadata
  console.log(req.file);

  // üßæ Access other form fields (if any)
  console.log(req.body);

  res.send('File uploaded successfully!');
});


//accessing file in both formate is same whether it is using storage or dest


// Single file upload
app.post('/profile', upload.single('avatar'), (req, res) => {
  console.log(req.file);   // one file
});

// Multiple files under one field
app.post('/gallery', upload.array('photos', 5), (req, res) => {
  console.log(req.files);  // array of files
});

// Multiple fields with different names
app.post('/profile', upload.fields([
  { name: 'avatar', maxCount: 1 },
  { name: 'coverImage', maxCount: 1 }
]), (req, res) => {
  console.log(req.files.avatar);     // array with avatar file
  console.log(req.files.coverImage); // array with cover image
});

// No files, only text fields
app.post('/form', upload.none(), (req, res) => {
  console.log(req.body);   // text fields only
});


http =>hyper text transfer protocol


url -uniform resource locator
uri - identifier
urn - name

// üåê HTTP HEADERS ‚Äî CHEAT SHEET STYLE

// üì¶ What are HTTP headers?
// Headers = metadata sent as key-value pairs with every HTTP request and response
// Used for: caching, authentication, managing state, compression, etc.

// üß≠ Types of Headers:

// 1Ô∏è‚É£ Request Headers ‚Üí sent from client (e.g., browser)
//     - Examples: Authorization, User-Agent, Accept, Cookie

// 2Ô∏è‚É£ Response Headers ‚Üí sent from server
//     - Examples: Set-Cookie, Content-Type, Cache-Control

// 3Ô∏è‚É£ Representation Headers ‚Üí describe encoding/compression
//     - Examples: Content-Encoding, Content-Language

// 4Ô∏è‚É£ Payload Headers ‚Üí describe actual data
//     - Examples: Content-Length, Content-Type

// ‚ö†Ô∏è Legacy Note:
// "X-" prefix headers (e.g., X-Powered-By) were common pre-2012 but are now deprecated


// üåê HTTP HEADERS ‚Äî MOST COMMON, CORS, SECURITY

// üî∏ Most Common Headers
// Accept: 'application/json'         // Client expects JSON response
// User-Agent: 'Mozilla/5.0'          // Info about konsi application se req aayi hai eg: browser,postman
// Authorization: 'Bearer <token>'    // Used for authentication
// Content-Type: 'application/json'   // Format of request body
// Cookie: 'sessionId=abc123'         // Client-side state management
// Cache-Control: 'no-cache'          // Caching behavior

these below does not do anything these are just internal policies of companies that kha kha se req aa skti hai
ye sirf header info  but isme aapko he code likhna hota hai

// üî∏ CORS Headers (Cross-Origin Resource Sharing)
// Access-Control-Allow-Origin: '*' or specific domain
// Access-Control-Allow-Credentials: true/false
// Access-Control-Allow-Methods: 'GET, POST, PUT, DELETE'

// üî∏ Security Headers
// Cross-Origin-Embedder-Policy: 'require-corp'         // Blocks untrusted embeds
// Cross-Origin-Opener-Policy: 'same-origin'            // Isolates browsing context
// Content-Security-Policy: "default-src 'self'"        // Prevents XSS, data injection
// X-XSS-Protection: '1; mode=block'                    // Legacy XSS protection (deprecated)

// üåê HTTP METHODS ‚Äî CHEAT SHEET

// Basic set of operations used to interact with a server

// üîπ GET
// Retrieve a resource (e.g., fetch user profile, list of posts)

// üîπ HEAD[less use]
// Like GET but returns only headers (no body); used for metadata checks

// üîπ OPTIONS[less use]
// Ask the server what methods are allowed on a resource (CORS preflight)

// üîπ TRACE
// Loopback test ‚Äî echoes the request back for debugging

// üîπ DELETE
// Remove a resource (e.g., delete user, remove post)

// üîπ PUT
// Replace a resource entirely (idempotent ‚Äî same result every time)

// üîπ POST
// Create or interact with a resource (commonly used to add new data)

// üîπ PATCH
// Modify part of a resource (partial update ‚Äî not full replacement)



// üåê HTTP STATUS CODES ‚Äî CHEAT SHEET

// üîπ 1xx ‚Äî Informational
// 100: Continue               // Client should continue with request
// 102: Processing             // Server has accepted but not completed the request

// üîπ 2xx ‚Äî Success
// 200: OK                     // Standard success response
// 201: Created                // Resource successfully created
// 202: Accepted               // Request accepted but not yet processed

// üîπ 3xx ‚Äî Redirection
// 307: Temporary Redirect     // Resource temporarily moved
// 308: Permanent Redirect     // Resource permanently moved

// üîπ 4xx ‚Äî Client Error[client se info sahi se nhi aayi hai]
// 400: Bad Request            // Malformed syntax or invalid request
// 401: Unauthorized           // Authentication required[u r lofgin but u r not authorised]
// 402: Payment Required       // Reserved for future use
// 404: Not Found              // Resource doesn't exist

// üîπ 5xx ‚Äî Server Error
// 500: Internal Server Error  // Generic server failure
// 504: Gateway Timeout        // Server didn‚Äôt get response from upstream





//Think of ApiError as a custom envelope for your backend errors ‚Äî
//it wraps the raw error in a structured format so your API responses
//are clean, predictable, and easy to debug.

class ApiError extends Error {
  constructor(
    statusCode,
    message = "Something went wrong",
    errors = [],
    stack = ""
  ) {
    super(message);
    this.statusCode = statusCode;
    this.data = null;
    this.message = message;
    this.success = false;
    this.errors = errors;

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

export { ApiError };

// ---------------- STACK HANDLING IN ApiError ----------------

// Every Error object in JS has a "stack" property
// - It's a string showing the call path (functions + line numbers)
// - Example output:
//   ApiError: Something went wrong
//       at someFunction (file.js:10:5)
//       at anotherFunction (file.js:20:3)

// In ApiError constructor:
// if (stack) {
//   this.stack = stack;
//   // üëâ If a custom stack string is passed in, use it directly.
//   // Example:
//   // new ApiError(400, "Bad Request", [], "Custom stack trace here")
//   // => err.stack === "Custom stack trace here"
// } else {
//   Error.captureStackTrace(this, this.constructor);
//   // üëâ If no custom stack is provided:
//   // - Node.js auto-generates a stack trace
//   // - captureStackTrace attaches the breadcrumb trail of calls
//   // - Excludes the constructor itself for cleaner output
//   // - Helps developers debug by showing where the error originated
// }

if (
    [fullname, email, username, password].some((field) => field?.trim() === "")
  )
// [fullname, email, username, password]
// üëâ Creates an array containing the four variables

// .some(callback)
// üëâ Array method that checks if *at least one* element
//    satisfies the condition inside the callback
// üëâ Returns true if any element passes, false otherwise

// (field) => field?.trim() === ""
// üëâ Callback function run on each element (fullname, email, etc.)
// üëâ field?.trim():
//    - ?. is optional chaining ‚Üí avoids errors if field is null/undefined
//    - .trim() removes whitespace from start and end of the string
// üëâ === "" checks if the trimmed string is empty

// So overall:
// - Loop through [fullname, email, username, password]
// - For each field, trim whitespace
// - If any field is empty (""), .some() returns true
// - Otherwise, returns false



// Multer configuration: handle multiple file fields in a single form submission
upload.fields([
  {
    name: "avatar",    // field name expected in the form-data (e.g. <input type="file" name="avatar">)
    maxCount: 1        // allow only 1 file for this field; Multer will still store it in an array
  },
  {
    name: "coverImage", // another field name (e.g. <input type="file" name="coverImage">)
    maxCount: 1         // allow only 1 file for this field as well
  }
]);

// After this middleware runs, Multer will populate req.files like:
// {
//   avatar: [ { ...fileObject } ],      // array containing the uploaded avatar file
//   coverImage: [ { ...fileObject } ]   // array containing the uploaded cover image file
// }
//
// Each fileObject includes metadata such as:
// fieldname, originalname, mimetype, destination, filename, path, size
//
// Example access:
// const avatarLocalPath = req.files?.avatar?.[0]?.path;       // path of uploaded avatar
// const coverImageLocalPath = req.files?.coverImage?.[0]?.path; // path of uploaded cover image
//
// Note: [0] is required because Multer always stores files in arrays,
// even if maxCount = 1.

//=============================uploading file on cloudinary======================================

const uploadOnCloudinary = async (localFilePath) => {
  try {
    if (!localFilePath) return null;
    //upload the file on cloudinary
    const response = await cloudinary.uploader.upload(localFilePath, {
      resource_type: "auto",//it will automatically detect the type of file
    });
    console.log("file uploaded on cloudinary ", response.url); 
    return response;
  } catch (error) {
    fs.unlinkSync(localFilePath);//remove the file from local server if any error occurs
    console.log("Error in uploading file on cloudinary", error);
    return null;
  }
};

{
  asset_id: "abc123xyz",        // unique ID for the asset
  public_id: "folder/filename", // the public identifier you can use to access it
  version: 1678901234,          // version number
  width: 800,                   // width in pixels (for images)
  height: 600,                  // height in pixels
  format: "jpg",                // file format
  resource_type: "image",       // type of resource (image, video, raw, etc.)
  created_at: "2026-01-02T14:21:00Z", // upload timestamp
  bytes: 123456,                // file size in bytes
  type: "upload",               // delivery type
  url: "http://res.cloudinary.com/.../filename.jpg", // direct URL to the file
  secure_url: "https://res.cloudinary.com/.../filename.jpg" // HTTPS URL
}





// Using Mongoose .select() to control which fields are returned
// -------------------------------------------------------------
// User.findById(user._id) ‚Üí finds the user document by its unique _id
// .select("-password -refreshToken") ‚Üí exclude these fields from the result
//   - The minus sign (-) means "do not include this field"
//   - Useful for hiding sensitive data like hashed passwords or tokens
//
// Example:
// Without .select ‚Üí result includes all fields (name, email, password, refreshToken, etc.)
// With .select("-password -refreshToken") ‚Üí result excludes those fields
//
// So createdUser will contain only safe fields (like _id, name, email),
// while password and refreshToken are filtered out.
const createdUser = await User.findById(user._id).select("-password -refreshToken");




visit 30 min video 15 it tells you something important abt postman