pro tips =>
1.whenever talk to database you must use try and catch and async await.
2.think as database is in difft continent so u shld alw use async await.

try {
    const connectionInstance = await mongoose.connect(`${process.env.MONGODB_URL}/${DB_NAME}`);
    console.log(`\n MongoDB connected !! DB HOST: ${connectionInstance.connection.host}`);//this is tell whole url where mongodb connection happens
    //this is to check if we by mistake we connect to difft url than production and get to know on which connection we are connecting
  } catch (error) {
    console.log("MONGODB connection failed ", error);//these logs are very impotant to see where i m doing the errors
    process.exit(1);
    // process.exit(code)
    // -> Immediately stops the Node.js process
    // -> Exit code convention:
    //    0 = success (program finished correctly)
    //    1 = failure (program crashed or critical error)
    // -> Often used in scripts, CI/CD, or when app cannot recover
  }


We use mongoose-aggregate-paginate-v2 so our apps don‚Äôt get overloaded when
showing lots of data. It breaks big results into small, easy-to-read pages ‚Äî
just like flipping through a comic book instead of carrying the whole library at once.
we will use it in video.models.js



we will use cloudnary and multer for uploading file 


multer =>it will not process any form which is not multipart(therefor enctype="multipart/form-data" is needed)
for uploading file
<form action="/upload" method="post" enctype="multipart/form-data">
  <input type="file" name="myFile" />
  <button type="submit">Upload</button>
</form>


- enctype ‚Üí Stands for encoding type. It tells the browser how to encode the form data before sending it to the server.
- multipart/form-data ‚Üí Used when your form includes file uploads.
- It splits the form data into multiple parts (text fields + binary file data).
- Each part is separated by a boundary string.


// üì¶ MULTER SETUP FOR FILE UPLOADS

const express = require('express')         // Import Express framework
const multer = require('multer')           // Import Multer middleware

// üóÇÔ∏è Configure Multer to store uploaded files in 'uploads/' directory

// ================= Multer Config Cheat Sheet =================
//
// 1. Using `dest`
// -------------------------------------------------------------
// const upload = multer({ dest: 'uploads/' });
// - Quick setup: tells Multer to save files in 'uploads/' folder.
// - Filenames are auto-generated (random safe IDs).
// - No control over naming or dynamic destination.
// - Good for demos, testing, or when you don‚Äôt care about filenames.
//
// üß™ This setup allows you to handle file uploads like:
// app.post('/profile', upload.single('avatar'), (req, res) => {
//   console.log(req.file)   // Access uploaded file metadata
//   console.log(req.body)   // Access other form fields
//   res.send('File uploaded!')
// })

// 2. Using `storage`
// -------------------------------------------------------------
// const storage = multer.diskStorage({
//   destination: (req, file, cb) => cb(null, 'uploads/'), // custom folder
//   filename: (req, file, cb) => cb(null, Date.now() + '-' + file.originalname) // custom name
// });
// const upload = multer({ storage: storage });
// - Full control over where files go and how they‚Äôre named.
// - Can use logic (timestamps, user IDs, file types).
// - Production‚Äëready: predictable filenames, easy to save paths in DB.
//
 
// üöÄ Create Multer instance with diskStorage
const upload = multer({ storage: storage });

// üõ†Ô∏è Route to handle file upload
app.post('/upload', upload.single('myFile'), (req, res) => {
  // üì¶ Access uploaded file metadata
  console.log(req.file);

  // üßæ Access other form fields (if any)
  console.log(req.body);

  res.send('File uploaded successfully!');
});


//accessing file in both formate is same whether it is using storage or dest


// Single file upload
app.post('/profile', upload.single('avatar'), (req, res) => {
  console.log(req.file);   // one file
});

// Multiple files under one field
app.post('/gallery', upload.array('photos', 5), (req, res) => {
  console.log(req.files);  // array of files
});

// Multiple fields with different names
app.post('/profile', upload.fields([
  { name: 'avatar', maxCount: 1 },
  { name: 'coverImage', maxCount: 1 }
]), (req, res) => {
  console.log(req.files.avatar);     // array with avatar file
  console.log(req.files.coverImage); // array with cover image
});

// No files, only text fields
app.post('/form', upload.none(), (req, res) => {
  console.log(req.body);   // text fields only
});


http =>hyper text transfer protocol


url -uniform resource locator
uri - identifier
urn - name

// üåê HTTP HEADERS ‚Äî CHEAT SHEET STYLE

// üì¶ What are HTTP headers?
// Headers = metadata sent as key-value pairs with every HTTP request and response
// Used for: caching, authentication, managing state, compression, etc.

// üß≠ Types of Headers:

// 1Ô∏è‚É£ Request Headers ‚Üí sent from client (e.g., browser)
//     - Examples: Authorization, User-Agent, Accept, Cookie

// 2Ô∏è‚É£ Response Headers ‚Üí sent from server
//     - Examples: Set-Cookie, Content-Type, Cache-Control

// 3Ô∏è‚É£ Representation Headers ‚Üí describe encoding/compression
//     - Examples: Content-Encoding, Content-Language

// 4Ô∏è‚É£ Payload Headers ‚Üí describe actual data
//     - Examples: Content-Length, Content-Type

// ‚ö†Ô∏è Legacy Note:
// "X-" prefix headers (e.g., X-Powered-By) were common pre-2012 but are now deprecated


// üåê HTTP HEADERS ‚Äî MOST COMMON, CORS, SECURITY

// üî∏ Most Common Headers
// Accept: 'application/json'         // Client expects JSON response
// User-Agent: 'Mozilla/5.0'          // Info about konsi application se req aayi hai eg: browser,postman
// Authorization: 'Bearer <token>'    // Used for authentication
// Content-Type: 'application/json'   // Format of request body
// Cookie: 'sessionId=abc123'         // Client-side state management
// Cache-Control: 'no-cache'          // Caching behavior

these below does not do anything these are just internal policies of companies that kha kha se req aa skti hai
ye sirf header info  but isme aapko he code likhna hota hai

// üî∏ CORS Headers (Cross-Origin Resource Sharing)
// Access-Control-Allow-Origin: '*' or specific domain
// Access-Control-Allow-Credentials: true/false
// Access-Control-Allow-Methods: 'GET, POST, PUT, DELETE'

// üî∏ Security Headers
// Cross-Origin-Embedder-Policy: 'require-corp'         // Blocks untrusted embeds
// Cross-Origin-Opener-Policy: 'same-origin'            // Isolates browsing context
// Content-Security-Policy: "default-src 'self'"        // Prevents XSS, data injection
// X-XSS-Protection: '1; mode=block'                    // Legacy XSS protection (deprecated)

// üåê HTTP METHODS ‚Äî CHEAT SHEET

// Basic set of operations used to interact with a server

// üîπ GET
// Retrieve a resource (e.g., fetch user profile, list of posts)

// üîπ HEAD[less use]
// Like GET but returns only headers (no body); used for metadata checks

// üîπ OPTIONS[less use]
// Ask the server what methods are allowed on a resource (CORS preflight)

// üîπ TRACE
// Loopback test ‚Äî echoes the request back for debugging

// üîπ DELETE
// Remove a resource (e.g., delete user, remove post)

// üîπ PUT
// Replace a resource entirely (idempotent ‚Äî same result every time)

// üîπ POST
// Create or interact with a resource (commonly used to add new data)

// üîπ PATCH
// Modify part of a resource (partial update ‚Äî not full replacement)



// üåê HTTP STATUS CODES ‚Äî CHEAT SHEET

// üîπ 1xx ‚Äî Informational
// 100: Continue               // Client should continue with request
// 102: Processing             // Server has accepted but not completed the request

// üîπ 2xx ‚Äî Success
// 200: OK                     // Standard success response
// 201: Created                // Resource successfully created
// 202: Accepted               // Request accepted but not yet processed

// üîπ 3xx ‚Äî Redirection
// 307: Temporary Redirect     // Resource temporarily moved
// 308: Permanent Redirect     // Resource permanently moved

// üîπ 4xx ‚Äî Client Error[client se info sahi se nhi aayi hai]
// 400: Bad Request            // Malformed syntax or invalid request
// 401: Unauthorized           // Authentication required[u r lofgin but u r not authorised]
// 402: Payment Required       // Reserved for future use
// 404: Not Found              // Resource doesn't exist

// üîπ 5xx ‚Äî Server Error
// 500: Internal Server Error  // Generic server failure
// 504: Gateway Timeout        // Server didn‚Äôt get response from upstream





//Think of ApiError as a custom envelope for your backend errors ‚Äî
//it wraps the raw error in a structured format so your API responses
//are clean, predictable, and easy to debug.

class ApiError extends Error {
  constructor(
    statusCode,
    message = "Something went wrong",
    errors = [],
    stack = ""
  ) {
    super(message);
    this.statusCode = statusCode;
    this.data = null;
    this.message = message;
    this.success = false;
    this.errors = errors;

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

export { ApiError };

// ---------------- STACK HANDLING IN ApiError ----------------

// Every Error object in JS has a "stack" property
// - It's a string showing the call path (functions + line numbers)
// - Example output:
//   ApiError: Something went wrong
//       at someFunction (file.js:10:5)
//       at anotherFunction (file.js:20:3)

// In ApiError constructor:
// if (stack) {
//   this.stack = stack;
//   // üëâ If a custom stack string is passed in, use it directly.
//   // Example:
//   // new ApiError(400, "Bad Request", [], "Custom stack trace here")
//   // => err.stack === "Custom stack trace here"
// } else {
//   Error.captureStackTrace(this, this.constructor);
//   // üëâ If no custom stack is provided:
//   // - Node.js auto-generates a stack trace
//   // - captureStackTrace attaches the breadcrumb trail of calls
//   // - Excludes the constructor itself for cleaner output
//   // - Helps developers debug by showing where the error originated
// }

if (
    [fullname, email, username, password].some((field) => field?.trim() === "")
  )
// [fullname, email, username, password]
// üëâ Creates an array containing the four variables

// .some(callback)
// üëâ Array method that checks if *at least one* element
//    satisfies the condition inside the callback
// üëâ Returns true if any element passes, false otherwise

// (field) => field?.trim() === ""
// üëâ Callback function run on each element (fullname, email, etc.)
// üëâ field?.trim():
//    - ?. is optional chaining ‚Üí avoids errors if field is null/undefined
//    - .trim() removes whitespace from start and end of the string
// üëâ === "" checks if the trimmed string is empty

// So overall:
// - Loop through [fullname, email, username, password]
// - For each field, trim whitespace
// - If any field is empty (""), .some() returns true
// - Otherwise, returns false



// Multer configuration: handle multiple file fields in a single form submission
upload.fields([
  {
    name: "avatar",    // field name expected in the form-data (e.g. <input type="file" name="avatar">)
    maxCount: 1        // allow only 1 file for this field; Multer will still store it in an array
  },
  {
    name: "coverImage", // another field name (e.g. <input type="file" name="coverImage">)
    maxCount: 1         // allow only 1 file for this field as well
  }
]);

// After this middleware runs, Multer will populate req.files like:
// {
//   avatar: [ { ...fileObject } ],      // array containing the uploaded avatar file
//   coverImage: [ { ...fileObject } ]   // array containing the uploaded cover image file
// }
//
// Each fileObject includes metadata such as:
// fieldname, originalname, mimetype, destination, filename, path, size
//
// Example access:
// const avatarLocalPath = req.files?.avatar?.[0]?.path;       // path of uploaded avatar
// const coverImageLocalPath = req.files?.coverImage?.[0]?.path; // path of uploaded cover image
//
// Note: [0] is required because Multer always stores files in arrays,
// even if maxCount = 1.

//=============================uploading file on cloudinary======================================

const uploadOnCloudinary = async (localFilePath) => {
  try {
    if (!localFilePath) return null;
    //upload the file on cloudinary
    const response = await cloudinary.uploader.upload(localFilePath, {
      resource_type: "auto",//it will automatically detect the type of file
    });
    console.log("file uploaded on cloudinary ", response.url); 
    return response;
  } catch (error) {
    fs.unlinkSync(localFilePath);//remove the file from local server if any error occurs
    console.log("Error in uploading file on cloudinary", error);
    return null;
  }
};

{
  asset_id: "abc123xyz",        // unique ID for the asset
  public_id: "folder/filename", // the public identifier you can use to access it
  version: 1678901234,          // version number
  width: 800,                   // width in pixels (for images)
  height: 600,                  // height in pixels
  format: "jpg",                // file format
  resource_type: "image",       // type of resource (image, video, raw, etc.)
  created_at: "2026-01-02T14:21:00Z", // upload timestamp
  bytes: 123456,                // file size in bytes
  type: "upload",               // delivery type
  url: "http://res.cloudinary.com/.../filename.jpg", // direct URL to the file
  secure_url: "https://res.cloudinary.com/.../filename.jpg" // HTTPS URL
}





// Using Mongoose .select() to control which fields are returned
// -------------------------------------------------------------
// User.findById(user._id) ‚Üí finds the user document by its unique _id
// .select("-password -refreshToken") ‚Üí exclude these fields from the result
//   - The minus sign (-) means "do not include this field"
//   - Useful for hiding sensitive data like hashed passwords or tokens
//
// Example:
// Without .select ‚Üí result includes all fields (name, email, password, refreshToken, etc.)
// With .select("-password -refreshToken") ‚Üí result excludes those fields
//
// So createdUser will contain only safe fields (like _id, name, email),
// while password and refreshToken are filtered out.
const createdUser = await User.findById(user._id).select("-password -refreshToken");




visit 30 min video 15 it tells you something important abt postman




diffce between refce token and access token =>


/*
================ Access Token vs Refresh Token =================



1Ô∏è‚É£ Access Token
- Purpose: Used to access protected APIs/routes.
- Lifespan: Short-lived (e.g., 15min ‚Äì 1h)
- Sent with API requests in headers: Authorization: Bearer <access_token>
- Storage: Memory, localStorage, or cookie
- Security: If stolen, risk is limited due to short lifespan

2Ô∏è‚É£ Refresh Token
- Purpose: Used to get a new access token without asking the user to log in again.
- Lifespan: Long-lived (e.g., 7‚Äì10 days)
- Storage: httpOnly cookie (recommended) or secure storage
- Security: High risk if stolen (can mint new access tokens)
- Not sent on every API request ‚Äî only when refreshing access token

================ Key Differences =================

| Feature          | Access Token              | Refresh Token                  |
|-----------------|---------------------------|--------------------------------|
| Purpose         | Access APIs/resources    | Renew access token             |
| Lifespan        | Short (minutes‚Äìhours)    | Long (days‚Äìweeks)              |
| Storage         | Memory / localStorage / cookie | HttpOnly cookie / secure storage |
| Security Risk   | Low (short-lived)        | High (can generate new access tokens) |
| Sent in requests| Yes (Authorization header) | No, only during refresh        |
| Rotation        | Not rotated              | Should rotate / can revoke     |

================ Analogy =================
- Access Token = Your room key (works only a short time)
- Refresh Token = Front desk master card (get new keys without leaving hotel)

================ Best Practices =================
- Keep access tokens short-lived
- Keep refresh tokens secure (httpOnly cookie)
- Validate refresh token carefully before issuing new access token
*/




// =======================
// FRONTEND (React / Vanilla JS)
// =======================

// -----------------------
// 1Ô∏è‚É£ LOGIN FUNCTION
// -----------------------
// - User submits username + password
// - We call backend /login
// - Backend responds with { accessToken }
// - We save the token in localStorage (or cookie)
async function login(username, password) {
  try {
    const res = await axios.post("http://localhost:8000/login", {
      username,
      password
    });

    // Save token securely
    localStorage.setItem("accessToken", res.data.accessToken);

    console.log("Login successful, token stored!");
  } catch (err) {
    console.error("Login failed:", err.response?.data || err.message);
  }
}

// -----------------------
// 2Ô∏è‚É£ GET TOKEN HELPER
// -----------------------
// - Retrieve token from localStorage
// - Used in API calls
function getToken() {
  return localStorage.getItem("accessToken");
}

// -----------------------
// 3Ô∏è‚É£ API CALL WITH TOKEN
// -----------------------
// - Attach token to Authorization header
// - Server reads it via req.header("authorization")
async function getUserProfile() {
  const token = getToken();

  if (!token) {
    console.error("No token found, please login first!");
    return;
  }

  try {
    const res = await axios.get("http://localhost:8000/api/user", {
      headers: {
        Authorization: `Bearer ${token}` // üëà this is what Express middleware checks
      }
    });

    console.log("User profile:", res.data);
  } catch (err) {
    console.error("Error fetching profile:", err.response?.data || err.message);
  }
}

// -----------------------
// 4Ô∏è‚É£ LOGOUT FUNCTION
// -----------------------
// - Remove token from storage
// - User must login again to get a new token
function logout() {
  localStorage.removeItem("accessToken");
  console.log("Logged out, token cleared!");
}

// -----------------------
// 5Ô∏è‚É£ USAGE EXAMPLE
// -----------------------
// - Call login, then fetch profile
// login("girish", "1234").then(() => getUserProfile());



//this is an synchronous function so we dont not async and await thing
jwt.sign(
        {
            _id:this._id
        },
        process.env.REFRESH_TOKEN_SECRET,
        {
            expiresIn:process.env.REFRESH_TOKEN_EXPIRY
        }
)

async function gives an promise





//how to get subscriber 


whenever anyone subscribe a channel one new document will be created .document wil contain who subscribed and channel 
so whenever we want to know how many have subscribed to an channel we will see document that will contain that particular
channel and if i want to see abt any user that it subscribed to how many channels i will just select document where 
subscriber value


short -> if want subscriber than select channels of particular value
         if want how many channel subscribed than just select document
         with particular subcriber value

/*
===========================================
üìÑ Subscription Tracking System (Cheat Sheet)
===========================================

# Document Structure (each subscription event)
{
  subscriber: "User123",   // üë§ Who subscribed
  channel: "TechTalks",    // üì∫ Channel they subscribed to
  timestamp: "2026-01-05T12:19:00Z" // ‚è∞ When it happened
}

# Queries / Use Cases

1. Count subscribers of a channel
   ‚Üí COUNT documents WHERE channel = "TechTalks"

2. Count channels a user subscribed to
   ‚Üí COUNT documents WHERE subscriber = "User123"

3. List all subscribers of a channel
   ‚Üí SELECT subscriber WHERE channel = "TechTalks"

4. List all channels a user subscribed to
   ‚Üí SELECT channel WHERE subscriber = "User123"

# Suggested Schema (MongoDB style)
Collection: "subscriptions"
Fields:
  - subscriber (String)
  - channel (String)
  - timestamp (Date)

# Mental Model
Think of it like a guestbook:
- Each line = one subscription entry
- To know how many signed for an event (channel) ‚Üí filter by channel
- To know how many events a person signed ‚Üí filter by subscriber

===========================================
*/

whenever anyone subscribe a channel one new document will be created .document wil contain who subscribed and channel 
so whenever we want to know how many have subscribed to an channel we will see document that will contain that particular
channel and if i want to see abt any user that it subscribed to how many channels i will just select document where 
subscriber value

aggregation pipeline

/*
===========================================================
üìä MongoDB Aggregation Pipeline ‚Äî Valid Definitions + Notes
===========================================================

# üß© Definition
Aggregation Pipeline = A framework in MongoDB that processes documents 
through a sequence of stages. Each stage performs an operation on the 
input documents and passes the results to the next stage. 
‚Üí Think of it as a "data conveyor belt" üöö.

# üîë Core Stages with Valid Definitions

1. $match
   - Definition: Filters documents by a condition (like WHERE in SQL).
   - Example: { $match: { status: "active" } }

2. $group
   - Definition: Groups documents by a specified key and applies 
     accumulator expressions (e.g., $sum, $avg).
   - Example: { $group: { _id: "$category", total: { $sum: 1 } } }

3. $project
   - Definition: Reshapes each document by including, excluding, or 
     computing new fields (like SELECT in SQL).
   - Example: { $project: { name: 1, year: { $year: "$date" } } }

4. $sort
   - Definition: Orders documents by specified fields.
   - Example: { $sort: { total: -1 } } // descending

5. $limit
   - Definition: Restricts the number of documents passed to the next stage.
   - Example: { $limit: 5 }

6. $skip
   - Definition: Skips a specified number of documents (used for pagination).
   - Example: { $skip: 10 }

7. $lookup
   - Definition: Performs a left outer join with another collection.
   - Example: { $lookup: { from: "users", localField: "userId", foreignField: "_id", as: "userInfo" } }

8. $unwind
   - Definition: Deconstructs an array field into multiple documents, 
     one per array element.
   - Example: { $unwind: "$tags" }

9. $count
   - Definition: Returns the count of documents that pass through the pipeline.
   - Example: { $count: "totalDocs" }

10. $addFields
    - Definition: Adds new fields or updates existing ones in documents.
    - Example: { $addFields: { fullName: { $concat: ["$firstName", " ", "$lastName"] } } }

11. $out
    - Definition: Writes the results of the pipeline to a new collection.
    - Example: { $out: "summaryCollection" }

12. $merge
    - Definition: Writes results to an existing collection, merging with existing docs.
    - Example: { $merge: { into: "reports", whenMatched: "merge", whenNotMatched: "insert" } }

# üõ†Ô∏è Example Pipeline
db.collectionName.aggregate(pipeline,options)//we use options very rarely
here pipeline is array of difft operations,

db.orders[collection name].aggregate([
  { $match: { status: "completed" } },               
  { $group: { _id: "$customerId", totalSpent: { $sum: "$amount" } } }, 
  { $sort: { totalSpent: -1 } },                     
  { $limit: 5 }                                     
])

# ‚ö° Mental Model
- $match ‚Üí "Gatekeeper" üö™ (filters docs)
- $group ‚Üí "Organizer" üì¶ (bins docs + aggregates)
- $project ‚Üí "Sculptor" üé® (reshapes docs)
- $sort ‚Üí "Judge" üìä (orders docs)
- $lookup ‚Üí "Bridge Builder" üåâ (joins collections)
- $unwind ‚Üí "Splitter" ‚úÇÔ∏è (explodes arrays)

# üß† Mnemonic
M ‚Üí Match  
G ‚Üí Group  
P ‚Üí Project  
S ‚Üí Sort  
L ‚Üí Lookup  
U ‚Üí Unwind  

Phrase: "My Great Pipeline Shapes Large Universes" üåå

===========================================================
*/


/*
===========================================================
üë§ Subscription Aggregation ‚Äî Lucid Walkthrough
===========================================================

# Stage 1: $match
- First, we pick ONE user from the "User" collection.
- Condition: username === the one you passed in.
- Think: "Find the person named 'targetuser'."

-----------------------------------------------------------

# Stage 2: $lookup (subscribers)
- Now we look into the "subscriptions" collection.
- Rule: find all docs where channel === this user's _id.
- Result: an array called "subscribers".
- Meaning: "Who follows this user?"

Example shape:
subscribers = [
  { subscriber: A, channel: targetuser },
  { subscriber: B, channel: targetuser }
]

-----------------------------------------------------------

# Stage 3: $lookup (subscribedTo)
- Again we look into "subscriptions".
- Rule: find all docs where subscriber === this user's _id.
- Result: an array called "subscribedTo".
- Meaning: "Which channels does this user follow?"

Example shape:
subscribedTo = [
  { subscriber: targetuser, channel: X },
  { subscriber: targetuser, channel: Y }
]

-----------------------------------------------------------

# Stage 4: $addFields
We add 3 extra fields to make life easier:

1) subscribersCount
   - Count how many docs are in "subscribers".
   - ‚Üí "How many people follow this user?"

2) channelsSubscribedToCount
   - Count how many docs are in "subscribedTo".
   - ‚Üí "How many channels does this user follow?"

3) isSubscribed
   - Check if the current logged‚Äëin user (req.user._id)
     is inside the "subscribers" list.
   - ‚Üí "Am I following this user?"

-----------------------------------------------------------

# Final Output
You end up with ONE user document enriched like this:

{
  _id: targetuserId,
  username: "targetuser",
  subscribers: [...],              // full list of followers
  subscribedTo: [...],             // full list of channels they follow
  subscribersCount: 2,             // number of followers
  channelsSubscribedToCount: 2,    // number of channels they follow
  isSubscribed: true               // whether YOU follow them
}

===========================================================
Mental Model:
- Stage 1 ‚Üí "Find the person"
- Stage 2 ‚Üí "Collect their fans"
- Stage 3 ‚Üí "Collect their idols"
- Stage 4 ‚Üí "Add quick stats"
===========================================================
*/



/*
===========================================================
üìä Stage: $project ‚Äî Include/Exclude Fields
===========================================================

# What $project does
- It reshapes the final output document.
- You explicitly say which fields you want to keep (1 = include).
- Any field not listed will be excluded (unless you set it to 1 too).

-----------------------------------------------------------

# In your case:
{
  $project: {
    fullname: 1,
    username: 1,
    subscribersCount: 1,
    channelsSubscribedToCount: 1,
    isSubscribed: 1,
    avatar: 1,
    coverImage: 1,
    email: 1,
    createdAt: 1
  }
}

Meaning:
- Keep only these fields in the final result.
- Drop everything else (like the raw "subscribers" and "subscribedTo" arrays).

-----------------------------------------------------------

# Why this is useful
- Makes the response lighter: you don‚Äôt send giant arrays of subscription docs.
- Focuses on the "summary stats" and profile info you actually need.
- Cleaner API response for frontend consumption.

-----------------------------------------------------------

# Final Output Shape
Instead of a heavy doc with nested arrays, you‚Äôll get something like:

{
  fullname: "Target User",
  username: "targetuser",
  subscribersCount: 2,             // number of followers
  channelsSubscribedToCount: 2,    // number of channels they follow
  isSubscribed: true,              // whether YOU follow them
  avatar: "https://.../avatar.png",
  coverImage: "https://.../cover.png",
  email: "target@example.com",
  createdAt: "2025-12-01T10:00:00Z"
}

-----------------------------------------------------------

# Mental Model
Think of $project as the "final sculptor" üé®:
- Earlier stages collected fans, idols, and stats.
- $project trims the clutter and shows only the polished profile card.
===========================================================
*/


if we write req.user._id we will get string why

/*
===========================================================
üîç Why req.user._id is a string with Mongoose
===========================================================

# Mongoose behavior:
- MongoDB stores _id as ObjectId.
- Inside a Mongoose document, _id is an ObjectId.
- BUT when you serialize (toJSON / toObject / send via API),
  Mongoose automatically converts ObjectId ‚Üí string.
- Reason: JSON has no native ObjectId type, so it flattens it.

-----------------------------------------------------------
Example with Mongoose:
-----------------------------------------------------------
*/

const user = await User.findById("6789abc123...");

// Inside Mongoose doc:
console.log(user._id instanceof mongoose.Types.ObjectId); 
// true ‚Üí it's still an ObjectId

// After attaching to req.user (often via Passport/JWT):
req.user = user.toJSON(); // or user.toObject()
console.log(typeof req.user._id); 
// "string" ‚Üí converted during serialization

/*
===========================================================
üü¢ Native MongoDB Driver (no Mongoose)
===========================================================

# Behavior:
- When you fetch directly with the MongoDB driver,
  _id stays as an ObjectId.
- It does NOT auto-convert to string.

-----------------------------------------------------------
Example with native driver:
-----------------------------------------------------------
*/

const { MongoClient, ObjectId } = require("mongodb");
const client = new MongoClient("mongodb://localhost:27017");
await client.connect();
const db = client.db("test");
const users = db.collection("users");

const user = await users.findOne({ _id: new ObjectId("6789abc123...") });

console.log(user._id instanceof ObjectId); 
// true ‚Üí stays ObjectId

console.log(typeof user._id); 
// "object" ‚Üí not string

/*
===========================================================
üõ†Ô∏è How to get string in native driver
===========================================================

# Use .toString() on ObjectId
- If you want the string form, call .toString() manually.

-----------------------------------------------------------
Example:
-----------------------------------------------------------
*/

console.log(user._id.toString()); 
// "6789abc123..." ‚Üí string version

/*
===========================================================
‚ö° Summary Mental Model
===========================================================

- Mongoose: auto-converts ObjectId ‚Üí string when serializing.
- Native driver: keeps ObjectId as-is; you must call .toString() yourself.
- MongoDB itself always stores _id as ObjectId unless you override.

Think:
Mongoose = "auto-flattener" ü™û (gives you a string when exporting)
Native driver = "raw chip" ü™™ (you hold the ObjectId until you unwrap it)
===========================================================
*/


/*
===========================================================
üìå MongoDB $lookup ‚Äî Lucid Explanation
===========================================================

# What is $lookup?
- Imagine you have TWO collections (two boxes of records).
- $lookup is like saying: "For each item in Box A, 
  go peek into Box B and bring back the matching items."
- It‚Äôs MongoDB‚Äôs way of doing a JOIN (like in SQL).

-----------------------------------------------------------
# Simple Example
Collections:
Users:
{ _id: 1, name: "Alice" }
{ _id: 2, name: "Bob" }

Subscriptions:
{ subscriber: 1, channel: 2 }
{ subscriber: 3, channel: 2 }

Pipeline:
db.users.aggregate([
  {
    $lookup: {
      from: "subscriptions",   // look into this collection
      localField: "_id",       // field in Users
      foreignField: "channel", // field in Subscriptions
      as: "subscribers"        // new array field name
    }
  }
])

Result:
{
  _id: 2,
  name: "Bob",
  subscribers: [
    { subscriber: 1, channel: 2 },
    { subscriber: 3, channel: 2 }
  ]
}

Meaning:
- For Bob (user _id=2), MongoDB looked into Subscriptions
  and found all docs where channel=2.
- It attached them as an array called "subscribers".

-----------------------------------------------------------
# Key Points
- $lookup always creates an ARRAY field (even if empty).
- If no matches are found, you still get subscribers: [].
- It‚Äôs a LEFT OUTER JOIN ‚Üí keep all docs from the main collection.

-----------------------------------------------------------
# Mental Model
Think of $lookup as a "bridge builder" üåâ:
- You stand on one side (Users).
- You build a bridge to another side (Subscriptions).
- You bring back all the matching records and attach them
  to your original document.

===========================================================
*/